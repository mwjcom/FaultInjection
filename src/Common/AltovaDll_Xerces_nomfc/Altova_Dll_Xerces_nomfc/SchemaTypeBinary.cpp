////////////////////////////////////////////////////////////////////////
//
// SchemaTypeBinary.cpp
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "Altova.h"
#include "AltovaException.h"
#include "SchemaTypeString.h"
#include "SchemaTypeBinary.h"

namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBinaryBase
//
////////////////////////////////////////////////////////////////////////


CSchemaBinaryBase::CSchemaBinaryBase()
: m_nSize( 0 )
, m_pData( NULL )

{
}


CSchemaBinaryBase::CSchemaBinaryBase( const CSchemaBinaryBase& rOther )
: m_nSize( 0 )
, m_pData( NULL )

{
	Clone( rOther );
}


CSchemaBinaryBase::CSchemaBinaryBase( const unsigned char* pData, int nSize )
: m_nSize( 0 )
, m_pData( NULL )

{
	Clone( pData, nSize );
}




CSchemaBinaryBase::~CSchemaBinaryBase()
{
	Empty();
}





void CSchemaBinaryBase::SetData( const unsigned char* pData, int nSize )
{
	Empty();
	Clone( pData, nSize );
}


bool CSchemaBinaryBase::ToBool() const
{
	if( !CSchemaType::ToBool() )
		return false;

	return !( m_pData == NULL );
}


void CSchemaBinaryBase::Empty()
{
	CSchemaType::Empty();

	if( m_pData )
		delete[] m_pData;
	m_pData = NULL;
	m_nSize = 0;

}


CSchemaType& CSchemaBinaryBase::Assign( const CSchemaType& rOther )
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	const CSchemaBinaryBase* pBinType = dynamic_cast<const CSchemaBinaryBase*>( &rOther );
	if( pBinType != NULL )
	{
		SetData( pBinType->GetData(), pBinType->GetSize() );
		SetIsEmpty( pBinType->IsEmpty() );
		return *this;
	}

	ThrowIncompatibleTypesError();
	return *this;
}


void CSchemaBinaryBase::Clone( const CSchemaBinaryBase& rOther )
{
	m_nSize = rOther.m_nSize;
	if (m_nSize == 0)
	{
		m_pData = NULL;
		SetIsEmpty( true );
		return;
	}
	m_pData = new unsigned char[ m_nSize ];
	memcpy( m_pData, rOther.m_pData, m_nSize );

	SetIsEmpty( false );
}


void CSchemaBinaryBase::Clone( const unsigned char* pData, int nSize )
{
	m_nSize = nSize;
	if (m_nSize == 0)
	{
		m_pData = NULL;
		SetIsEmpty( true );
		return;
	}
	m_pData = new unsigned char[ m_nSize ];
	memcpy( m_pData, pData, m_nSize );
	
	SetIsEmpty( false );
}




////////////////////////////////////////////////////////////////////////
//
//  CSchemaHexBinary
//
////////////////////////////////////////////////////////////////////////


const TCHAR CSchemaHexBinary::sm_EncodeArray[] =
	_T("0123456789ABCDEF");


const char CSchemaHexBinary::sm_DecodeArray[] =
{

	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	 0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
};


CSchemaHexBinary::operator tstring() const
{
	if( IsEmpty()  ||  m_pData == NULL )
		return _T("");

	tstring s;
	s.reserve(m_nSize * 2);
	const unsigned char* pReader = m_pData;
	for (int i = 0; i < m_nSize; i++)
	{
		s += sm_EncodeArray[*pReader >> 4];
		s += sm_EncodeArray[*pReader & 0xF];
		pReader++;
	}
	return s;
}


bool CSchemaHexBinary::Parse( const TCHAR* szValue )
{
	if( !CSchemaType::Parse( szValue ) )
		return false;

	m_nSize = _tcslen(szValue) / 2;
	if (m_nSize == 0)
	{
		m_pData = NULL;

		SetIsEmpty( true );
		return false;
	}
	m_pData = new unsigned char[m_nSize];

	unsigned char* szDataWriter = m_pData;
	while (*szValue && *(szValue + 1))
	{
		char nDigit1 = sm_DecodeArray[*szValue++];
		char nDigit2 = sm_DecodeArray[*szValue++];
		if (nDigit1 == -1 ||nDigit2 == -1)
			ThrowFormatError();
		*szDataWriter++ = nDigit1 * 16 + nDigit2;
	}


	return !IsEmpty();
}


CSchemaType& CSchemaHexBinary::Assign(const CSchemaType& rOther)
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	const CSchemaString* pStrType = dynamic_cast<const CSchemaString*>( &rOther );
	if( pStrType )
	{
		Parse( ((tstring)*pStrType).c_str() );
		return *this;
	}

	return CSchemaBinaryBase::Assign( rOther );
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBase64Binary
//
////////////////////////////////////////////////////////////////////////


const TCHAR CSchemaBase64Binary::sm_EncodeArray[] =
	_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


const char CSchemaBase64Binary::sm_DecodeArray[] =
{

	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	62,	-1,	-1,	-1,	63,
	52,	53,	54,	55,	56,	57,	58,	59,	60,	61,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	 0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	10,	11,	12,	13,	14,
	15,	16,	17,	18,	19,	20,	21,	22,	23,	24,	25,	-1,	-1,	-1,	-1,	-1,
	-1,	26,	27,	28,	29,	30,	31,	32,	33,	34,	35,	36,	37,	38,	39,	40,
	41,	42,	43,	44,	45,	46,	47,	48,	49,	50,	51,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
};


CSchemaBase64Binary::CSchemaBase64Binary( const TCHAR* szValue )
{
	Decode( szValue, m_pData, m_nSize );
	SetIsEmpty( false );
}


CSchemaBase64Binary::operator tstring() const
{
	if( IsEmpty() ||  m_pData == NULL )
		return _T("");

	tstring sResult;
	TCHAR* szDst;
	int nDstSize;

	Encode( m_pData, m_nSize, szDst, nDstSize );
	sResult = szDst;
	delete[] szDst;
	return sResult;
}


bool CSchemaBase64Binary::Parse( const TCHAR* szValue )
{
	if( !CSchemaType::Parse( szValue ) )
		return false;

	Decode( szValue, m_pData, m_nSize );


	return !IsEmpty();
}


CSchemaType& CSchemaBase64Binary::Assign( const CSchemaType& rOther )
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	const CSchemaString* pStrType = dynamic_cast<const CSchemaString*>( &rOther );
	if( pStrType )
	{
		Parse( (( tstring )*pStrType).c_str() );
		return *this;
	}

	return CSchemaBinaryBase::Assign( rOther );
}


void CSchemaBase64Binary::Encode( unsigned char* pSrc, int nSrcSize, TCHAR*& rszDst, int& rnDstSize, int nMaxLineLength ) const
{
	int			nTmpSize, nAllocSize, nLineLength, i;
	TCHAR*			szDstWriter;
	unsigned long	bBuf;

	if (nSrcSize == 0)
	{
		rszDst = NULL;
		rnDstSize = 0;
		return;
	}

	nTmpSize	= nSrcSize * 4 / 3;
	nAllocSize	= nTmpSize + 8;
	if (nMaxLineLength > 0)
		nAllocSize += nTmpSize * 2 / nMaxLineLength;
	
	rszDst		= new TCHAR[nAllocSize];
	szDstWriter	= rszDst;

	nTmpSize	= nSrcSize / 3 * 3;
	rnDstSize	= 0;
	nLineLength	= 0;

	if (nMaxLineLength > 0)
	{
		for (i = 0; i < nTmpSize; i += 3)
		{
			bBuf = *(pSrc + i) << 16 | *(pSrc + i + 1) << 8 | *(pSrc + i + 2);
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 18) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 12) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >>  6) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[ bBuf        & 0x3F];
			rnDstSize += 4;

			nLineLength += 4;
			if (nMaxLineLength > 0 && nLineLength >= nMaxLineLength)
			{
				*szDstWriter++ = _T('\r');
				*szDstWriter++ = _T('\n');
				rnDstSize += 2;
				nLineLength = 0;
			}
		}
	}
	else
	{
		for (i = 0; i < nTmpSize; i += 3)
		{
			bBuf = *(pSrc + i) << 16 | *(pSrc + i + 1) << 8 | *(pSrc + i + 2);
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 18) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >> 12) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[(bBuf >>  6) & 0x3F];
			*szDstWriter++ = sm_EncodeArray[ bBuf        & 0x3F];
			rnDstSize += 4;
		}
	}

	int nRest = nSrcSize - nTmpSize;
	if (nRest == 2)
	{
		bBuf = *(pSrc + i) << 8 | *(pSrc + i + 1);
		*szDstWriter++ = sm_EncodeArray[(bBuf >> 10) & 0x3F];
		*szDstWriter++ = sm_EncodeArray[(bBuf >>  4) & 0x3F];
		*szDstWriter++ = sm_EncodeArray[(bBuf <<  2) & 0x3F];
		*szDstWriter++ = _T('=');
		rnDstSize += 4;
	}
	else if (nRest == 1)
	{
		bBuf = *(pSrc + i);
		*szDstWriter++ = sm_EncodeArray[(bBuf >>  2) & 0x3F];
		*szDstWriter++ = sm_EncodeArray[(bBuf <<  4) & 0x3F];
		*szDstWriter++ = _T('=');
		*szDstWriter++ = _T('=');
		rnDstSize += 4;
	}

	*szDstWriter = 0;
}


void CSchemaBase64Binary::Decode(const TCHAR* szSrc, unsigned char*& rpDst, int& rnDstSize)
{
	int			nSrcSize;
	const TCHAR*	szSrcReader;
	unsigned char*	pDstWriter;
	unsigned long	nBuf;
	int			nCount;

	szSrcReader	= szSrc;
	while (*szSrcReader && sm_DecodeArray[*szSrcReader] == -1)
	{
		szSrcReader++;
	}
	nSrcSize = _tcslen(szSrcReader);
	if (nSrcSize == 0)
	{
		rpDst = NULL;
		rnDstSize = 0;
		return;
	}

	rpDst		= new unsigned char[nSrcSize];
	pDstWriter	= rpDst;
	rnDstSize	= 0;
	nBuf		= 0;
	nCount		= 0;

	while (*szSrcReader)
	{
		while (sm_DecodeArray[*szSrcReader] == -1)
		{
			if (!*++szSrcReader)
				goto finish;
		}

		nBuf |= sm_DecodeArray[*szSrcReader++];

		if (++nCount == 4)
		{
			*pDstWriter++ = (unsigned char)(nBuf >> 16);
			*pDstWriter++ = (unsigned char)(nBuf >>  8);
			*pDstWriter++ = (unsigned char) nBuf;
			rnDstSize += 3;
			nBuf = 0;
			nCount = 0;
		}
		else
		{
			nBuf <<= 6;
		}
	}

finish:
	if (nCount == 2)
	{
		*pDstWriter++ = (unsigned char)(nBuf >> 10);
		rnDstSize++;
	}
	else if (nCount == 3)
	{
		*pDstWriter++ = (unsigned char)(nBuf >> 16) & 0xFF;
		*pDstWriter++ = (unsigned char)(nBuf >>  8) & 0xFF;
		rnDstSize += 2;
	}
}


 

} // namespace altova
